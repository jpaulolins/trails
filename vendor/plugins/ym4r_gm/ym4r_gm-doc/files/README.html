<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu May 22 09:54:00 -0300 2008</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>YM4R/GM plugin for Rails</h1>
<p>
This is the latest version of the YM4R/GM plugin for Rails (YM4RGMP4R?).
Its aim is to facilitate the use of Google Maps from Rails application. It
includes and enhances all the web application-related functionalities found
in the YM4R gem as of version 0.4.1.
</p>
<h2>Getting Started</h2>
<p>
I present here the most common operations you would want to do with
YM4R/GM. Read the rest of the documents if you want more details.
</p>
<p>
In your controller, here is a typical initialization sequence in action
<tt>index</tt>:
</p>
<pre>
        def index
          @map = GMap.new(&quot;map_div&quot;)
          @map.control_init(:large_map =&gt; true,:map_type =&gt; true)
          @map.center_zoom_init([75.5,-42.56],4)
          @map.overlay_init(GMarker.new([75.6,-42.467],:title =&gt; &quot;Hello&quot;, :info_window =&gt; &quot;Info! Info!&quot;))
        end
</pre>
<p>
Here I create a GMap (which will be placed inside a DIV of id
<tt>map_div</tt>), add controls (large zoom slider and pan cross + map type
selector), set the center and the zoom and add a marker. Of these 4 steps
only the creation of the map and the setting of the center and the zoom are
absolutely necessary.
</p>
<p>
In your view, here is what you would have:
</p>
<pre>
        &lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;
        &lt;%= GMap.header %&gt;
        &lt;%= @map.to_html %&gt;
        &lt;/head&gt;&lt;body&gt;
        &lt;%= @map.div(:width =&gt; 600, :height =&gt; 400) %&gt;
        &lt;/body&gt;&lt;/html&gt;
</pre>
<p>
First you must output the header, used by all the maps of the page: It
includes the Google Maps API JS code and the JS helper functions of
YM4R/GM. Then we initialize the map by calling <tt>@map.to_html</tt>. In
the body, we need a DIV whose <tt>id</tt> is the same as the one passed to
the GMap constructor in the controller. The call to <tt>@map.div</tt>
outputs such a DIV. We pass to it options to set the width and height of
the map in the style attribute of the DIV.
</p>
<p>
<b>Note that you need to set a size for the map DIV element at some point
or the map will not be displayed.</b> You have a few ways to do this:
</p>
<ul>
<li>You define it yourself, wherever you want. Usually as part of the layout
definition in an external CSS.

</li>
<li>In the head of the document, through a CSS instruction output by
<tt>@map.header_width_height</tt>, to which you pass 2 arguments (width and
height).

</li>
<li>When outputting the DIV with <tt>@map.div</tt>, you can also pass an option
hash, with keys <tt>:width</tt> and <tt>:height</tt> and a style attribute
for the DIV element will be output.

</li>
</ul>
<p>
You can update the map trough RJS. Here is an action you can call from a
<tt>link_remote_tag</tt> which would do this:
</p>
<pre>
        def update
          @map = Variable.new(&quot;map&quot;)
          @marker = GMarker.new([75.89,-42.767],:title =&gt; &quot;Update&quot;, :info_window =&gt; &quot;I have been placed through RJS&quot;)
        end
</pre>
<p>
Here, I first bind the Ruby <tt>@map</tt> variable to the JS variable
<tt>map</tt>, which already exists in the client browser. <tt>map</tt> is
by default the name given to a map created from YM4R/GM (this could be
overriden by passing a second argument to the GMap constructor). Then I
create a marker.
</p>
<p>
And you would have inside the RJS template for the action:
</p>
<pre>
        page &lt;&lt; @map.clear_overlays
        page &lt;&lt; @map.add_overlay(@marker)
</pre>
<p>
Here I first clear the map of all overlays. Then I add the marker. Note
that the <tt>overlay_init</tt> is not used anymore since, as its name
indicates, this method is only for the initialization of the map.
</p>
<h2>Relation between the YM4R gem and the YM4R/GM plugin</h2>
<p>
They are completely independent from each other.
</p>
<p>
With the plugin, you don&#8216;t need the YM4R gem anymore, unless you want
to use the tilers or the Ruby helpers for the Yahoo! Maps Building Block
API&#8216;s and the Google Maps geocoding API. Please refer to the
documentation of the YM4R gem to know more about the functionalities in it.
</p>
<p>
Conversely, the YM4R gem does not need the plugin to work.
</p>
<h2>Installation</h2>
<p>
Install like any other Rails plugin:
</p>
<pre>
        ruby script/plugin install svn://rubyforge.org/var/svn/ym4r/Plugins/GM/trunk/ym4r_gm
</pre>
<p>
As part of the installation procedure, the JavaScript files found in the
<tt>PLUGIN_ROOT/javascript</tt> directory will be copied to the
<tt>RAILS_ROOT/public/javascripts/</tt> directory.
</p>
<p>
Moreover a <tt>gmaps_api_key.yml</tt> file will also be created in the
<tt>RAILS_ROOT/config/</tt> folder. If this file already exists (installed
for example by a previous version of the plugin), nothing will be done to
it, so you can keep your configuration data even after updating the plugin.
This file is a YAML representation of a hash, similar to the
<tt>database.yml</tt> file in that the primary keys in the file are the
different environments (development, test, production), since you will
probably need to have different Google Maps API keys depending on that
criteria (for example: a key for localhost for development and test; a key
for your host for production). If you don&#8216;t have any special need,
there will be only one key associated with each environment. If however,
you need to have multiple keys (for example if your app will be accessible
from multiple URLs, for which you need different keys), you can also
associate a hash to the environment, whose keys will be the different
hosts. In this case, you will need to pass a value to the <tt>:host</tt>
key when calling the method <tt>GMap.header</tt> (usually
<tt>@request.host</tt>).
</p>
<h2>Migration from the YM4R gem versions &lt;= 0.4.1</h2>
<p>
Apart from the installation of the plugin detailed above, you will also
need to delete the instructions to require the file and include the
Ym4r::GoogleMaps module in your controllers:
</p>
<pre>
        require 'ym4r'
        include Ym4r::GoogleMaps
</pre>
<p>
This lines are now not needed since the plugin is loaded as part of the
normal Rails loading procedure and the module is included when the plugin
is loaded.
</p>
<h2>Operations</h2>
<p>
You can use the library to display Google maps easily from Rails. The
version of the API used is v2. The library is engineered so updates to the
map through RJS/Ajax are possible. I have made available 2 in-depth
tutorials to show some of the functionalities of the library and how it can
be integrated with GeoRuby and the Spatial Adapter for Rails:
</p>
<ul>
<li><a
href="http://thepochisuperstarmegashow.com/2006/06/02/ym4r-georuby-spatial-adapter-demo">thepochisuperstarmegashow.com/2006/06/02/ym4r-georuby-spatial-adapter-demo</a>/

</li>
<li><a
href="http://thepochisuperstarmegashow.com/2006/06/03/google-maps-yahoo-traffic-mash-up">thepochisuperstarmegashow.com/2006/06/03/google-maps-yahoo-traffic-mash-up</a>/

</li>
</ul>
<p>
Following is some notes about manipulating Google Maps with the library:
</p>
<h3>Naming conventions</h3>
<p>
The names of the Ruby class follow the ones in the JavaScript Google Maps
API v2, except for GMap2, which in Ruby code is called simply GMap. To know
what is possible to do with each class, you should refer to the
documentation available on Google website.
</p>
<p>
On top of that, you have some convenience methods for initializing the map
(in the GMap class). Also, the constructors of some classes accept
different types of arguments to be converted later in the correct
JavaScript format. For example, the <tt>GMarker</tt> aclass accepts an
array of 2 floats as parameter, in addition of a GLatLng object, to
indicate its position. It also facilitates the attribution of an HTML info
window, displayed when the user clicks on it, since you can pass to the
constructor an options hash with the <tt>:info_window</tt> key and the text
to display as the value, instead of having to wire the response to a click
event yourself.
</p>
<h3>Binding JavaScript and Ruby</h3>
<p>
Since the Google Maps API uses JavaScript to create and manipulate a map,
most of what the library does is outputting JavaScript, although some
convenience methods are provided to simplify some common operations at
initialization time. When you create a YM4R mapping object (a Ruby object
which includes the MappingObject module) and call methods on it, these
calls are converted by the library into JavaScript code. At initialization
time, you can pass arbitrary JavaScript code to the
<tt>GMap#record_init</tt> and <tt>GMap#record_global_init</tt>.Then, at
update time, if you use Ruby-on-Rails as your web framework, you can update
your map through RJS by passing the result of the method calls to the
<tt>page &lt;&lt; </tt> method to have it then interpreted by the browser.
</p>
<p>
For example, here is a typical initialization sequence for a map
</p>
<pre>
        @map = GMap.new(&quot;map_div&quot;)
        @map.control_init(:large_map =&gt; true,:map_type =&gt; true)
        @map.center_zoom_init([35.12313,-110.567],12)
        @map.overlay_init GMarker.new([35.12878, -110.578],:title =&gt; &quot;Hello!&quot;)
        @map.record_init @map.add_overlay(GMarker.new([35.12878, -110.578],:title =&gt; &quot;Hello!&quot;))
</pre>
<p>
While <tt>center_zoom_init</tt>, <tt>control_init</tt> or
<tt>overlay_init</tt> (and generally all the GMap methods which end in
<tt>init</tt>) are one of the rare convenience methods that do not output
JavaScript, the <tt>add_overlay</tt> does. Actually, if you look at the
code of the GMap class, you won&#8216;t find any <tt>add_overlay</tt>
method, although in the documentation of the GMap2 class from the Google
Maps API documentation, you will find something about the
<tt>addOverlay</tt> JavaScript method. In fact, when you call on a mapping
object an unknow method, it is converted to a javascriptified version of
it, along with its arguments, and a string of JavaScript code is output. So
the <tt>@map.add_overlay&#8230;</tt> above is converted to
<tt>&quot;map.addOverlay(new GMarker(GLatLng.new(35.12878,
-110.578),{title:\&quot;Hello!\&quot;}))&quot;</tt>, which is then passed
to the <tt>record_init</tt> method of a Ruby GMap object to be later output
along with the rest of the initialization code. Any arbitrary JavaScript
code can be passed to the <tt>record_init</tt> method. Note that 2 last
lines of the previous code sample are strictly equivalent and since the
<tt>overlay_init</tt> version is a bit simpler, it should be preferred.
</p>
<h3>Initialization of the map</h3>
<p>
The map is represented by a GMap object. You need to pass to the
constructor the id of a DIV that will contain the map. You have to place
this DIV yourself in your HTML template. You can also optionnally pass to
the constructor the JavaScript name of the variable that will reference the
map, which by default will be global in JavaScript. You have convenience
methods to setup the controls, the center, the zoom, overlays, the
interface configuration (continuous zoom, double click zoom, dragging), map
types and the icons (which are also global). You can also pass arbitrary
JavaScript to <tt>record_init</tt> and <tt>record_global_init</tt>. Since,
by default, the initialization of the map is performed in a callback
function, if you want to have a globally accessible variable, you need to
use the <tt>global</tt> version.
</p>
<p>
You can also have multiple maps. Just make sure you give them different DIV
id&#8216;s, as well as different global variable names, when constructing
them:
</p>
<pre>
        @map1 = GMap(&quot;map1_div&quot;,&quot;map1&quot;)
        @map2 = GMap(&quot;map2_div&quot;,&quot;map2&quot;)
</pre>
<p>
The other absolutely necessary initialization step in the controller is the
setting of center and zoom:
</p>
<pre>
        @map1.center_zoom_init([49.12,-56.453],3)
</pre>
<p>
Withouth this code the map will display an empty grey rectangle with
Google&#8216;s logo.
</p>
<p>
Then in your template, you have 2 necessary calls:
</p>
<ul>
<li>The static <tt>GMap.header</tt>: Outputs the inclusion of the JavaScript
file from Google to make use of the Google Maps API and by default a style
declaration for VML objects, necessary to display polylines under IE. This
default can be overriddent by passing <tt>:with_vml =&gt; false</tt> as
option to the <tt>header</tt> method. You can also pass to this method a
<tt>:host</tt> option in order to select the correct key for the location
where your app is currently deployed, in case the current environment has
multiple possible keys. Usually, in this case, you should pass it
<tt>@request.host</tt>. Finally you can override all the key settings in
the configuration by passing a value to the <tt>:key</tt> key.

</li>
<li><tt>GMap#to_html</tt>: Outputs the initialization code of the map. By
default, it outputs the <tt>script</tt> tags and initializes the map in
response to the onload event of the JavaScript window object. You can call
<tt>to_html</tt> on each one of your maps to have them all initialized. You
can pass the option <tt>:full=&gt;true</tt> to the method to setup a
fullscreen map, which will also be resized when the window size changes.

</li>
</ul>
<p>
You can also use <tt>GMap#div</tt> to output the div element with the
correct <tt>id</tt>. You can pass it options <tt>:height</tt> and
<tt>:width</tt> to set the size of the div (although, as indicated below,
you have other ways to do that).
</p>
<p>
So you should have something like the following:
</p>
<pre>
        &lt;html&gt;&lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;
        &lt;%= GMap.header %&gt;
        &lt;%= @map.to_html %&gt;
        &lt;/head&gt;
        &lt;body&gt;&lt;%= @map.div(:width =&gt; 600,:height =&gt; 400) %&gt;&lt;/body&gt;
        &lt;/html&gt;
</pre>
<p>
<b>Note that you need to set a size for the map DIV element at some point
or the map will not be displayed.</b> You have a few ways to do this:
</p>
<ul>
<li>You define it yourself, wherever you want. Usually as part of the layout
definition in an external CSS.

</li>
<li>In the head of the document, through a CSS instruction output by
<tt>@map.header_width_height</tt>, to which you pass 2 arguments (width and
height).

</li>
<li>When outputting the DIV with <tt>@map.div</tt>, you can also pass an option
hash, with keys <tt>:width</tt> and <tt>:height</tt> and a style attribute
for the DIV element will be output.

</li>
</ul>
<h3>GMarkers</h3>
<p>
GMarkers are point of interests on a map. You can give a position to a
GMarker constructor either by passing it a 2D-array of coordinates, a
GLatLng object, an object of type Variable (which evaluates to a GLatLng
when interpreted in the browser) or an address, which will be geocoded when
the marker is initialized by the map.
</p>
<p>
You can pass options to the GMarker to customize the info window
(<tt>:info_window</tt> or <tt>:info_window_tabs</tt> options), the tooltip
(<tt>:title</tt> option) or the icon used (<tt>:icon</tt> option).
</p>
<p>
For example:
</p>
<pre>
        GMarker.new([12.4,65.6],:info_window =&gt; &quot;&lt;b&gt;I'm a Popup window&lt;/b&gt;&quot;,:title =&gt; &quot;Tooltip&quot;)
        GMarker.new(GLatLng.new([12.3,45.6]))
        GMarker.new(&quot;Rue Clovis Paris France&quot;, :title =&gt; &quot;geocoded&quot;)
</pre>
<h3>Update of the map</h3>
<p>
You are able to update the map through Ajax. In Ruby-on-Rails, you have
something called RJS, which sends JavaScript created on the server as a
response to an action, which is later interpreted by the browser. It is
usually used for visual effects and replacing or adding elements. It can
also accept arbitrary JavaScript and this is what YM4R uses.
</p>
<p>
For example, if you want to add a marker to the map, you need to do a few
things. First, you have to bind a Ruby mapping object to the global
JavaScript map variable. By default its name is <tt>map</tt>, but you could
have overriden that at initialization time. You need to do something like
this:
</p>
<pre>
        @map = Variable.new(&quot;map&quot;)
</pre>
<p>
<tt>map</tt> in the Variable constructor is the name of the global
JavaScript map variable. Then any method you call on <tt>@map</tt> will be
converted in JavaScript to a method called on <tt>map</tt>. In your RJS
code, you would do something like this to add a marker:
</p>
<pre>
        page &lt;&lt; @map.add_overlay(GMarker.new([12.1,12.76],:title =&gt; &quot;Hello again!&quot;))
</pre>
<p>
What is sent to the browser will be the fllowing JavaScript code:
</p>
<pre>
        map.addOverlay(new GMarker(new GLatLng(123123.1,12313.76),{title:\&quot;Hello again!\&quot;}))
</pre>
<h3>GPolyline</h3>
<p>
GPolylines are colored lines on the map. The constructor takes as argument
a list of GLatLng or a list of 2-element arrays, which will be transformed
into GLatLng for you. It can also take the color (in the <tt>rrggbb</tt>
form), the weight (an integer) and the opacity. These arguments are
optional though.
</p>
<p>
For example:
</p>
<pre>
        GPolyline.new([[12.4,65.6],[4.5,61.2]],&quot;#ff0000&quot;,3,1.0)
</pre>
<p>
Then you add it like any other overlay:
</p>
<pre>
        @map.overlay_init(polyline)
</pre>
<h3>GPolygon</h3>
<p>
GPolygons are colored areas on the map. As of 29/12, this feature is not
documented in the official GMaps API, but thanks to Steven Talcott Smith
(<a href="http://www.talcottsystems.com">www.talcottsystems.com</a>), it is
possible to use it now in ym4r.
</p>
<p>
The constructor takes as argument a list of GLatLng or a list of 2-element
arrays, which will be transformed into GLatLng for you. Note that for
polygons, the last point must be equal to the first, in order to have a
closed loop. It can also take the color (in the <tt>rrggbb</tt> form) of
the stroke, the weight of the stroke, the opacity of the stroke, as well as
the color of the fill and the opacity. These arguments are optional though.
</p>
<p>
For example:
</p>
<pre>
        GPolygon.new([[12.4,6.6],[4.5,1.2],[-5.6,-12.4],[12.4,6.6]],&quot;#ff0000&quot;,3,1.0,&quot;#00ff00&quot;,1.0)
</pre>
<p>
Then you add it like any other overlay:
</p>
<pre>
        @map.overlay_init(polygon)
</pre>
<h3>GMarkerGroup</h3>
<p>
A new type of GOverlay is available, called GMarkerGroup.
</p>
<p>
<b>To use it you would have to include in your HTML template the JavaScript
file <tt>markerGroup.js</tt> after the call to <tt>GMap.header</tt>
(because it extends the GOverlay class).</b> You should have something like
that in your template:
</p>
<pre>
        &lt;%= javascript_include_tag(&quot;markerGroup&quot;) %&gt;
</pre>
<p>
It is useful in 2 situations:
</p>
<ul>
<li>Display and undisplay a group of markers without referencing all of them.
You just declare your marker group globally and call <tt>activate</tt> and
<tt>deactivate</tt> on this group in response, for example, to clicks on
links on your page.

</li>
<li>Keeping an index of markers, for example, in order to show one of these
markers in reponse to a click on a link (the way Google Local does with the
results of the search).

</li>
</ul>
<p>
Here is how you would use it from your Ruby code:
</p>
<pre>
        @map = GMap.new(&quot;map_div&quot;)
        marker1 = GMarker.new([123.55,123.988],:info_window =&gt; &quot;Hello from 1!&quot;)
        marker2 = GMarker.new([87.123,18.9],:info_window =&gt;&quot;Hello from 2!&quot;)
        @map.overlay_global_init(GMarkerGroup.new(true,
                                        1 =&gt; marker1,
                                        2 =&gt; marker2),&quot;myGroup&quot;)
</pre>
<p>
Here I have created an active (ie which is going to be displayed when the
map is created) marker group called <tt>myGroup</tt> with 2 markers, which
I want to reference later. If I did not want to reference them later (I
just want to be able to display and undisplay the marker group), I could
have passed an array instead of the hash.
</p>
<p>
Then in your template, you could have that:
</p>
<pre>
        &lt;a href=&quot;#&quot; onclick=&quot;myGroup.showMarker(1);return false;&quot;&gt;Click here to display marker1&lt;/a&gt;
        &lt;a href=&quot;#&quot; onclick=&quot;myGroup.showMarker(2);return false;&quot;&gt;Click here to display marker2&lt;/a&gt;
        &lt;%= @map.div %&gt;
</pre>
<p>
When you click on one of the links, the corresponding marker has its info
window displayed.
</p>
<p>
You can call <tt>activate</tt> and <tt>deactivate</tt> to display or
undisplay a group of markers. You can add new markers with
<tt>addMarker(marker,id)</tt>. Again if you don&#8216;t care about
referencing the marker, you don&#8216;t need to pass an id. If the marker
group is active, the newly added marker will be displayed immediately.
Otherwise it will be displayed the next time the group is activated.
Finally, since it is an overlay, the group will be removed when calling
clearOverlays on the GMap object.
</p>
<p>
You can center and zoom on all the markers in the group by calling
<tt>GMarkerGroup#centerAndZoomOnMarkers()</tt> after the group has been
added to a map. So for example, if you would want to do that at
initalization time, you would do the following (assuming your marker group
has been declared as <tt>group</tt>):
</p>
<pre>
        @map.record_init group.center_and_zoom_on_markers
</pre>
<h3>GMarkerManager</h3>
<p>
It is a recent (v2.67) GMaps API class that manages the efficient display
of potentially thousands of markers. It is similar to the Clusterer (see
below) since markers start appearing at specified zoom levels. The
clustering behaviour has to be managed explicitly though by specifying the
cluster for smaller zoom levels and specify the expanded cluster for larger
zoom levels and so on. Note that it is not an overlay and is not added to
the map through an overlay_init call.
</p>
<p>
Here is an example of use:
</p>
<pre>
    @map = GMap.new(&quot;map_div&quot;)
    @map.control_init(:large_map =&gt; true, :map_type =&gt; true)
    @map.center_zoom_init([59.91106, 10.72223],3)
    srand 1234
    markers1 = []
    1.upto(20) do  |i|
      markers1 &lt;&lt; GMarker.new([59.91106 + 6 * rand - 3, 10.72223 + 6 * rand - 3],:title =&gt; &quot;OY-20-#{i}&quot;)
    end
    managed_markers1 = ManagedMarker.new(markers1,0,7)

    markers2 = []
    1.upto(200) do  |i|
      markers2 &lt;&lt; GMarker.new([59.91106 + 6 * rand - 3, 10.72223 + 6 * rand - 3],:title =&gt; &quot;OY-200-#{i}&quot;)
    end
    managed_markers2 = ManagedMarker.new(markers2,8,9)

    markers3 = []
    1.upto(1000) do  |i|
      markers3 &lt;&lt; GMarker.new([59.91106 +  6 * rand - 3, 10.72223 + 6 * rand - 3],:title =&gt; &quot;OY-300-#{i}&quot;)
    end
    managed_markers3= ManagedMarker.new(markers3,10)

    mm = GMarkerManager.new(@map,:managed_markers =&gt; [managed_markers1,managed_markers2,managed_markers3])
    @map.declare_init(mm,&quot;mgr&quot;)
</pre>
<h3>Clusterer</h3>
<p>
A Clusterer is a type of overlay that contains a potentially very large
group of markers. It is engineered so markers close to each other and
undistinguishable from each other at some level of zoom, appear as only one
marker on the map at that level of zoom. Therefore it is possible to have a
very large number of markers on the map at the same time and not having the
map crawl to a halt in order to display them. It has been slightly modified
from Jef Poskanzer&#8216;s original Clusterer2 code (see <a
href="http://www.acme.com/javascript">www.acme.com/javascript</a>/ for the
original version). The major difference with that version is that, in YM4R,
the clusterer is a GOverlay and can therefore be added to the map with
<tt>map.addOverlay(clusterer)</tt> and is cleared along with the rest of
overlays when <tt>map.clearOverlays()</tt> is called.
</p>
<p>
<b>In order to use a clusterer, you should include in your template page
the clusterer.js file after the call to <tt>GMap.header</tt> (because it
extends the GOverlay class).</b> You should have something like that in
your template:
</p>
<pre>
        &lt;%= javascript_include_tag(&quot;clusterer&quot;) %&gt;
</pre>
<p>
To create a clusterer, you should first create an array of all the GMarkers
that you want to include in the clusterer (you can still add more after the
clusterer has been added to the map though). When GMarkers close together
are grouped in one cluster (represented by another marker on the map) and
the user clicks on the cluster marker, a list of markers in the cluster is
displayed in the info windo with a description: By default it is equal to
the <tt>title</tt> of the markers (which is also displayed as a tooltip
when hovering on the marker with the mouse). If you don&#8216;t want that,
you can also pass to the GMarker constructor a key-value pair with key
<tt>:description</tt> to have a description different from the title. For
example, here is how you would create a clusterer:
</p>
<pre>
        markers = [GMarker.new([37.8,-90.4819],:info_window =&gt; &quot;Hello&quot;,:title =&gt; &quot;HOYOYO&quot;),
                  GMarker.new([37.844,-90.47819],:info_window =&gt; &quot;Namaste&quot;,:description =&gt; &quot;Chopoto&quot; , :title =&gt; &quot;Ay&quot;),
                  GMarker.new([37.83,-90.456619],:info_window =&gt; &quot;Bonjour&quot;,:title =&gt; &quot;Third&quot;),
        ]
        clusterer = Clusterer.new(markers,:max_visible_markers =&gt; 2)
</pre>
<p>
Of course, with only 3 markers, the whole clusterer thing is totally
useless. Usually, using the clusterer starts being interesting with
hundreds of markers. The options to pass the clusterer are:
</p>
<ul>
<li><tt>:max_visible_markers</tt>: Below this number of markers, no clustering
is performed. Defaults to 150.

</li>
<li><tt>:grid_size</tt>: The clusterer divides the visible area into a grid of
this size. Defaults to 5.

</li>
<li><tt>:min_markers_per_cluster</tt>: Below this number of markers a cluster
is not formed. Defaults to 5.

</li>
<li><tt>:max_lines_per_info_box</tt>: Number of lines to display in the info
window displayed when a cluster is clicked on by the user. Defaults to 10.

</li>
<li><tt>:icon</tt>: Icon to be used to mark a cluster. Defaults to
G_DEFAULT_ICON (the classic red marker).

</li>
</ul>
<p>
Then to add the clusterer to the map at initialization time, you proceed as
with a classic overlay:
</p>
<pre>
        @map.overlay_init clusterer
</pre>
<p>
To add new markers in RJS (if the clusterer has been declared globally with
overlay_global_init), you should do this:
</p>
<pre>
        page &lt;&lt; clusterer.add_marker(marker,description)
</pre>
<p>
In this case, the <tt>:description</tt> passed to the GMarker contructor
will not be taken into account. Only the <tt>description</tt> passed in the
call to <tt>add_marker</tt> will.
</p>
<h3>GeoRss Overlay</h3>
<p>
An group of markers taken from a Rss feed containing location information
in the W3C basic geo (WGS83 lat/lon) vocabulary and in the Simple GeoRss
format. See <a href="http://georss.org">georss.org</a> for more details.
The support for GeoRss relies on the MGeoRSS library by Mikel Maron (<a
href="http://brainoff.com/gmaps/mgeorss.html">brainoff.com/gmaps/mgeorss.html</a>),
although a bit modified, mostly to have the GeoRssOverlay respect the
GOverlay API. It has also been enhanced by Andrew Turner who added support
for the GeoRss Simple format.
</p>
<p>
<b>Note that the <tt>geoRssOverlay.js</tt> file must be included in the
HTML template in order to use this functionality.</b> You should have
something like that in your template:
</p>
<pre>
        &lt;%= javascript_include_tag(&quot;geoRssOverlay&quot;) %&gt;
</pre>
<p>
Here is how you would use it. First create the overlay at initialization:
</p>
<pre>
        def index
          @map = GMap.new(&quot;map_div&quot;)
          @map.control_init(:large_map =&gt; true)
          @map.center_zoom_init([38.134557,-95.537109],0)
          @map.overlay_init(GeoRssOverlay.new(url_for(:action =&gt; &quot;earthquake_rss&quot;))
        end
</pre>
<p>
Since it is not possible to make requests outside the domain where the
current page comes from, there is a need for a proxy. With the
GeoRssOverlay initialization above, the request will be made by the
<tt>earthquake_rss</tt> action, where the address to find the RSS feed will
be hardwired:
</p>
<pre>
        def earthquake_rss
           result = Net::HTTP.get_response(&quot;earthquake.usgs.gov&quot;,&quot;/eqcenter/recenteqsww/catalogs/eqs7day-M5.xml&quot;)
           render :xml =&gt; result.body
        end
</pre>
<p>
If you don&#8216;t want to hardwire the RSS feed location in an action, you
can. But you will have to pass the <tt>:proxy</tt> option to the
GeoRssOverlay constructor. When requesting the RSS feed, the browser will
in fact call the proxy with the actual URL of the RSS feed in the
<tt>q</tt> parameter of the request. Here is how you would initialize the
GeoRssOverlay that way:
</p>
<pre>
        @map.overlay_init(GeoRssOverlay.new(&quot;http://earthquake.usgs.gov/eqcenter/recenteqsww/catalogs/eqs7day-M5.xml&quot;,
        :proxy =&gt; url_for(:action =&gt; &quot;proxy&quot;)))
</pre>
<p>
And here is an example of <tt>proxy</tt> action:
</p>
<pre>
        def proxy
            result = Net::HTTP.get_response(URI.parse(@params[:q]))
            render :xml =&gt; result.body
        end
</pre>
<p>
You should probably do some checks to ensure the proxy is not abused but it
is of your responsibility.
</p>
<p>
Another option can be passed to the GeoRssOverlay constructor to set an
icon to be used by the markers of the overlay: <tt>:icon</tt>. By default
it is equal to the default icon (the classic red one).
</p>
<p>
In the view, you should have something like the following:
</p>
<pre>
        &lt;html&gt;
        &lt;head&gt;&lt;title&gt;Testing GeoRss&lt;/title&gt;
        &lt;%= GMap.header(:with_vml =&gt; false) %&gt;
        &lt;%= javascript_include_tag(&quot;geoRssOverlay&quot;) %&gt;
        &lt;%= @map.header_width_height(600,400) %&gt;
        &lt;%= @map.to_html %&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;%= @map.div %&gt;
        &lt;/body&gt;
        &lt;/html&gt;
</pre>
<p>
Note the inclusion of the <tt>geoRssOverlay.js</tt> file.
</p>
<p>
Other options to pass to the GeoRssOverlay constructor are the following:
</p>
<ul>
<li><tt>:list_div</tt>: In case you want to make a list of all the markers,
with a link on which you can click in order to display the info on the
marker, use this option to indicate the ID of the DIV (that you must place
yourself on your page).

</li>
<li><tt>:list_item_class&lt;tt&gt;: class of the DIV containing each item of
the list. Ignored if option &lt;tt&gt;:list_div</tt> is not set.

</li>
<li><tt>:limit</tt>: Maximum number of items to display on the map.

</li>
<li><tt>:content_div</tt>: Instead of having an info window appear, indicates
the ID of the DIV where this info should be displayed.

</li>
</ul>
<h3>Adding new map types</h3>
<p>
It is now possible to easily add new map types, on top of the already
existing ones, like G_SATELLITE_MAP or G_NORMAL_MAP. The imagery for these
new map types can come from layers of the standard map types or can be
taken either from a WMS server or from pretiled images on a server (that
can be generated with a tool that comes with the YM4R gem: refer to the
README of the gem to know more about it).
</p>
<p>
For exemple, here is how you would setup layers from a public WMS server of
the DMAP team of the American Navy:
</p>
<pre>
        layer = WMSLayer.new(&quot;http://columbo.nrlssc.navy.mil/ogcwms/servlet/WMSServlet/AccuWeather_Maps.wms&quot;,
        &quot;20:3,6:3,0:27,0:29,6:19&quot;,
        :copyright =&gt; {'prefix' =&gt; &quot;Map Copyright 2006&quot;, 'copyright_texts'=&gt; [&quot;DMAP&quot;]},
        :use_geographic =&gt; true, :opacity =&gt; 0.8)
</pre>
<p>
This sets up a connection to a WMS service, requesting layers
<tt>20:3,6:3,0:27,0:29,6:19</tt> (you would have to look at the
GetCapabilities document of the service to know what the valid layers are).
The copyright notice attributes the data to DMAP. The images will be 80%
opaque. For the rest of the options, the default values are used: default
styles (<tt>:style</tt> option), PNG format (<tt>:format</tt> option),
valid for all zoom levels (<tt>:zoom_range</tt> option). The option
<tt>:merc_proj</tt> is irrelevant here since the <tt>:use_geographic</tt>
option is true.
</p>
<p>
The arguments <tt>:use_geographic</tt> and <tt>:merc_proj</tt> warrant some
explanation. The Google Maps are in the Simple Mercator projection in the
WGS84 datum and currently do not support the display of data in projections
other than that (at least if you want to display markers and lines on top
of it). Unfortunately, different WMS servers do not identify this
projection the same way. So you can give to the WMSLayer constructor your
server type through the <tt>:merc_proj</tt> option and it will figure out
what is the correct identifier. Currently, this works only for
<tt>:mapserver</tt> (EPSG:54004) and <tt>:geoserver</tt> (EPSG:41001). For
others you can directly pass a number corresponding to the EPSG definition
of the simple Mercator projection of your server. On top of that, some
servers just don&#8216;t support the Simple Mercator projection. This is
why there is a <tt>:use_geographic</tt> option, that can be set to
<tt>true</tt>. It is in order to tell the WMSLayer that it should request
its tiles using LatLon coordinates in the WGS84 datum (which should be
supported by any server in a consistant way). Unfortunately it is not
perfect since the deformation is quite important for low zoom levels (&lt;
5 for the US). Higher than that, the deformation is not that visible.
However, if you control the WMS server, it is recommended that you
don&#8216;t use <tt>:use_geographic</tt> and instead use the
<tt>:merc_proj</tt> option and setup the Mercator projection in your server
if it is not done by default.
</p>
<p>
<b>Note that you need to include the <tt>wms-gs.js</tt> javascript file in
your HTML page in order to make use of the WMSLayer functionality.</b> You
should have something like that in your template:
</p>
<pre>
        &lt;%= javascript_include_tag(&quot;wms-gs&quot;) %&gt;
</pre>
<p>
This file uses code by John Deck with the participation of others (read the
top of the javascript file to know more).
</p>
<p>
Here is how to define a pretiled layer:
</p>
<pre>
        layer = PreTiledLayer.new(&quot;http://localhost:3000/tiles&quot;,
        :copyright =&gt; {'prefix' =&gt; &quot;Map C 2006&quot;, 'copyright_texts' =&gt; [&quot;Open Atlas&quot;]},
        :zoom_range =&gt; 13..13, :opacity =&gt; 0.7, :format =&gt; &quot;gif&quot;)
</pre>
<p>
I tell the PreTiledLayer constructor where I can find the tiles, setup the
Copyright string, the valid zooms for the map, the opacity and the format.
Tiles must have standardized names:
<tt>tile_#{zoom}_#{x_tile}_#{y_tile}.#{format}</tt> (here the format is
&quot;gif&quot;). You can use tools found in the YM4R gem to generate tiles
in this format either from local maps or from WMS servers (useful to create
tiles from geographic data files without having to run a map server or to
cache images from slow servers). Again refer to the documentation of the
gem for more information on how to do this.
</p>
<p>
Instead of having the tiles requested directly, you can also decide to have
an action on the server which takes care of it. You can used the class
PreTiledLayerFromAction for this. In this case, the first argument of the
constructor is an url of an action. The arguments <tt>x</tt>, <tt>y</tt>
and <tt>z</tt> will be passed to it.
</p>
<pre>
        layer = PreTiledLayerFromAction.new(url_for(:action =&gt; :get_tile),
        :copyright =&gt; {'prefix' =&gt; &quot;Map C 2006&quot;, 'copyright_texts' =&gt; [&quot;Open Atlas&quot;]},
        :zoom_range =&gt; 13..14, :opacity =&gt; 0.7)
</pre>
<p>
The other constructor arguments have the same meaning as PreTiledLayer.
Here is an uninteresting example of action that serves tiles:
</p>
<pre>
        def get_tile
          x = @params[:x]
          y = @params[:y]
          z = @params[:z]
          begin
            send_file &quot;#{RAILS_ROOT}/public/tiles/tile_#{z}_#{x}_#{y}.png&quot; ,
                :type =&gt; 'image/png', :disposition =&gt; 'inline'
          rescue Exception
            render :nothing =&gt; true
          end
        end
</pre>
<p>
You can add a layer to a new map type the following way:
</p>
<pre>
        map_type = GMapType.new(layer,&quot;My WMS&quot;)
</pre>
<p>
This is actually the simplest configuration possible. Your map type has
only one data layer and is called &quot;My WMS&quot;. You can add more that
one layer: Either one that you have created yourself or existing ones. For
example:
</p>
<pre>
        map_type = GMapType.new([GMapType::G_SATELLITE_MAP.get_tile_layers[0],layer,GMapType::G_HYBRID_MAP.get_tile_layers[1]],
        &quot;Test WMS&quot;)
</pre>
<p>
Here for the &quot;Test WMS&quot; map type, we also take the first layer of
the &quot;Satellite&quot; map type in the background and overlay the second
layer of the &quot;Hybrid&quot; map type (roads, country boundaries,
etc&#8230; transparently overlaid on top of the preceding layers) so when
the &quot;Test WMS&quot; map type is selected in the interface, all three
layers will be displayed.
</p>
<p>
Finally to add a map type to a GMap:
</p>
<pre>
        @map.add_map_type_init(map_type)
</pre>
<p>
If you want to wipe out the existing map types (for example the 3 default
ones), you can add a <tt>false</tt> argument to the
<tt>add_map_type_init</tt> method and the <tt>map_type</tt> will be the
only one.
</p>
<p>
If you want to setup the map as the default one when the map is initially
displayed, you should first declare the map type then add it to the map as
indicated above and finally setting it as the default map type:
</p>
<pre>
        @map.declare_init(map_type,&quot;my_map_type&quot;)
        @map.add_map_type_init(map_type)
        @map.set_map_type_init(map_type)
</pre>
<p>
Future versions of the plugin may simplify that.
</p>
<h3>Google Geocoding</h3>
<p>
A helper to perform geocoding on the server side (in Ruby) is included.
Here is an example of request:
</p>
<pre>
        results = Geocoding::get(&quot;Rue Clovis Paris&quot;)
</pre>
<p>
You can also pass to the <tt>get</tt> method an options hash to manage the
various API key options (see the section on <tt>GMap.header</tt> for
details). <tt>results</tt> is an array of Geocoding::Placemark objects,
with 2 additional attributes: <tt>status</tt> and <tt>name</tt>. You should
check if <tt>status</tt> equals <tt>Geocoding::GEO_SUCCESS</tt> to know if
the request has been successful. You can then access the various data
elements.
</p>
<p>
Here is an example that will display a marker on Paris:
</p>
<pre>
        results = Geocoding::get(&quot;Rue Clovis Paris&quot;)
        if results.status == Geocoding::GEO_SUCCESS
                coord = results[0].latlon
                @map.overlay_init(GMarker.new(coord,:info_window =&gt; &quot;Rue Clovis Paris&quot;))
        end
</pre>
<p>
You could also have performed the geocoding on the client side with the
following code, which is functionnality equivalent to the code above:
</p>
<pre>
        GMarker.new(&quot;Rue Clovis Paris&quot;,:info_window =&gt; &quot;Rue Clovis Paris&quot;)
</pre>
<h3>Local Search</h3>
<p>
Local Search control has been added to the map and control objects. There
are two places you need to implement it to get it to work. This is because
the local search control needs an additional library added to the import as
well as the control added to the map.
</p>
<p>
In your controller, you add &#8217;:local_search =&gt; true&#8217; to the
@map.control_init like this: @map = GMap.new(&quot;map_div&quot;)
@map.control_init(:large_map =&gt; true, :map_type =&gt; true,
:local_search =&gt; true)
</p>
<p>
And in your view, you pass &#8217;:local_search =&gt; true&#8217; to the
GMap.header like this: &lt;%= GMap.header(:local_search =&gt; true) %&gt;
&lt;%= @map.to_html %&gt; &lt;%= @map.div(:width =&gt; 600, :height =&gt;
400) %&gt;
</p>
<p>
You can pass options to the control_init as well. They are: :anchor =&gt;
[:bottom_left (default), :bottom_right, :top_left, :top_right]
:offset_width =&gt; 10 (default) :offset_height =&gt; 20 (default)
</p>
<p>
So if you wanted the local search control to be at the bottom right of the
map, 30 pixel in from the right and 20 pixels above the bottom it would
look like this: @map.control_init(:large_map =&gt; true, :map_type =&gt;
true, :local_search =&gt; true, :anchor =&gt; :bottom_right, :offset_width
=&gt; 30, :offset_height =&gt; 20)
</p>
<h2>Recent changes</h2>
<ul>
<li>Local Search overlay added. See above for implementation.

</li>
<li>GMarker can now be placed by address (in addition to coordinates). Some
code to geocode the address when the marker is initialized is added

</li>
<li>Addition of a <tt>center_zoom_on_points_init</tt> to center and zoom on a
group of pixel

</li>
<li>In JS, addition of methods to GMap2 and GMarkerGroup to center and zoom on
a group of points or markers (thanks to Glen Barnes)

</li>
<li>Support for easy setup of fullscreen maps

</li>
</ul>
<h2>TODO</h2>
<ul>
<li>Add support for easy manipulation of external Google Maps-related
libraries: Advanced tooltip manipulation (PdMarker),&#8230;

</li>
<li>Addition of all GeoRss vocabularies (with all features: polylines&#8230;)
to the geoRssOverlay extension

</li>
<li>Tutorials

</li>
</ul>
<h2>Disclaimer</h2>
<p>
This software is not endorsed in any way by Google.
</p>
<h2>Acknowledgement</h2>
<p>
The YM4R/GM plugin bundles JavaScript libraries from John Deck (WMS layers
on Google Maps), Jef Poskanzer (Clusterer on Google Maps) and Mikel Maron
(GeoRss on Google Maps).
</p>
<h2>License</h2>
<p>
The YM4R/GM plugin is released under the MIT license. The
<tt>clusterer.js</tt> file is redistributed with a different license (but
still compatible with the MIT license). Check the top of the file in
<tt>PLUGIN_ROOT/javascript</tt> to know more.
</p>
<h2>Support</h2>
<p>
Any questions, enhancement proposals, bug notifications or corrections can
be sent to <a
href="mailto:guilhem.vellut+ym4r@gmail.com">guilhem.vellut+ym4r@gmail.com</a>.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>